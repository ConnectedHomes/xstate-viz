var examples = {
    omni: "Machine({\n    id: 'example',\n    initial: 'leaf',\n    states: {\n      leaf: {\n        on: {\n          NEXT: 'compound'\n        }\n      },\n      'another leaf': {\n        entry: ['one', 'two'],\n        exit: ['three', 'four'],\n        on: {\n          NEXT: {\n            target: 'compound',\n            cond: function someCondition() { return true }\n          },\n          NEVER: {\n            target: 'leaf',\n            cond: function falseCondition() { return false }\n          }\n        }\n      },\n      compound: {\n        initial: 'child 1',\n        states: {\n          'child 1': {\n            on: {\n              NEXT: 'child 2'\n            }\n          },\n          'child 2': {\n            initial: 'subchild 1',\n            states: {\n              'subchild 1': {\n                on: { NEXT: 'subchild 2' }\n              },\n              'subchild 2': {\n                on: { NEXT: 'subchild 3', PREV: 'subchild 1' }\n              },\n              'subchild 3': {\n                type: 'final'\n              }\n            }\n          }\n        },\n        on: {\n          PREV: 'leaf',\n          NEXT: 'parallel',\n          INTERNAL: '.child 1'\n        }\n      },\n      parallel: {\n        type: 'parallel',\n        states: {\n          foo: {},\n          bar: {\n            initial: 'one',\n            states: {\n              one: {\n                on: {\n                  NEXT: 'two'\n                }\n              },\n              two: {\n                on: {\n                  NEXT: 'three',\n                  PREV: 'two'\n                }\n              },\n              three: {\n                on: {\n                  SELF: 'three',\n                  SELF_INTERNAL: '.',\n                  PREV: 'two',\n                  CYCLE: 'one'\n                }\n              }\n            }\n          },\n          baz: {\n            initial: 'one',\n            states: {\n              one: {\n                on: {\n                  TWO_CHILD: 'two.foo'\n                }\n              },\n              two: {\n                initial: 'foo',\n                states: {\n                  foo: {},\n                  bar: {},\n                  history: {\n                    type: 'history'\n                  }\n                }\n              },\n              three: {}\n            }\n          }\n        }\n      }\n    }\n  })",
    light: "\n  // Available variables:\n  // Machine (machine factory function)\n  // assign (action)\n  // XState (all XState exports)\n  \n  const fetchMachine = Machine({\n    id: 'fetch',\n    context: { attempts: 0 },\n    initial: 'idle',\n    invoke: {\n      id: 'child',\n      src: () => Machine({\n        initial: 'foo',\n        context: { value: 3 },\n        states: {\n          foo: {\n            invoke: Machine({ initial: 'yah', states: { yah: {\n              on: {\n                FOO: { target: 'yah' }\n              }\n            }}}),\n            on: { EVENT: 'bar' }\n          },\n          bar: {}\n        }\n      })\n    },\n    states: {\n      idle: {\n        on: {\n          FETCH: {\n            target: 'pending',\n            cond: function canFetch() { return true },\n            actions: 'fetchData'\n          }\n        },\n        entry: ['one', 'two', 'three'],\n        exit: [send('EVENT', { to: 'child' }), 'foobar']\n      },\n      pending: {\n        entry: assign({\n          attempts: ctx => ctx.attempts + 1\n        }),\n        after: {\n          TIMEOUT: 'rejected'\n        },\n        on: {\n          RESOLVE: 'fulfilled',\n          REJECT: 'rejected'\n        }\n      },\n      fulfilled: {\n        initial: 'first',\n        states: {\n          first: {\n            on: {\n              NEXT: 'second'\n            }\n          },\n          second: {\n            on: {\n              NEXT: 'third'\n            }\n          },\n          third: {\n            type: 'final'\n          }\n        }\n      },\n      rejected: {\n        entry: assign({\n          ref: () => spawn(Machine({ initial: 'foo', states: {foo: {}}}))\n        }),\n        initial: 'can retry',\n        states: {\n          'can retry': {\n            on: {\n              '': {\n                target: 'failure',\n                cond: 'maxAttempts'\n              }\n            }\n          },\n          failure: {\n            on: {\n              RETRY: undefined,\n            },\n            type: 'final'\n          }\n        },\n        on: {\n          RETRY: 'pending'\n        }\n      }\n    }\n  }, {\n    guards: {\n      maxAttempts: ctx =>  ctx.attempts >= 5\n    },\n    delays: {\n      TIMEOUT: 2000\n    }\n  });\n  ",
    another: "\n  const m = Machine({\n    initial: 'b',\n    context: {\n      foo: undefined\n    },\n    states: {\n      b: { on: {T:'yeah'}},\n      yeah: {\n        entry: assign({\n          foo: () => {\n            return spawn(Promise.resolve(42));\n          }\n        })\n      }\n    }\n  });\n  "
};
export { examples };
